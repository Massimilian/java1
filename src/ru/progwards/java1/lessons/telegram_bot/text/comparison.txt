Сравнение примитивов осуществляется при помощи оператора «==». Если мы сравниваем объекты, их необходимо сравнивать при помощи метода equals, а сам метод обязательно переопределять. Сравнение объектов с не переопределённым equals будет приводить к тому, что будут сравниваться только сами ссылки объекта (ведут ли они к одному и тому же объекту и являются ли ссылкой на один объект), но не сами объекты (то есть по большому счёту equals будет работать как «==»). Метод equals уже переопределён у многих объектов, например, у String.
Также объекты сравниваются при помощи метода compareTo, который, в отличии от equals, не наследуется из Object, а реализует интерфейс Comparable. Сравнение объектов типа String осуществляется посимвольно (пока не будет найдено различие). Для всех остальных классов-обёрток метод compareTo реализован.
При сравнивании объектов следует переопределить методы equals() и hashcode() – они изначально имеются у Object. Hashcode – это число типа int, которое соотносится конкретно с этим объектом. Задача hashcode – повышение быстродействия при поиске, добавлении и удалении объекта в коллекции; в идеале у каждого объекта уникальный hashcode, но часто это не совсем так. В классе Object hashcode – это адрес объекта в памяти, поэтому каждый объект класса Object уникален.
System.out.println(new Object().hashCode()); // выведет hashcode конкретного объекта
System.out.println(new Object().hashCode()); // выведет hashcode другого объекта; соответственно, hashcode будет другой

Если мы выведем хэш-код обёртки одного и того же значения, то он будет совпадать.
System.out.println(new Integer(5).hashCode()); // выведет 5
System.out.println(new Integer(5).hashCode()); // опять выведет 5
System.out.println(new String("a").hashCode()); // выведет 97, что соответствует порядковому символу 'a' в Unicode
System.out.println(new String("ab").hashCode()); // но hashcode строки - это не сумма значений строки. Например, тут будет 3105.
System.out.println(new String("ab").hashCode()); // тут - тоже 3105.
System.out.println(new String("ba").hashCode()); //... а тут - 3135.

Хэш-таблица – это аналог библиотеки. Объекты – это книги, которые лежат строго согласно каталогу. Когда нам нужен некий объект, мы ищем его по каталогу. 
Если вдруг хэш коды двух объектов совпали – возникает коллизия. Теперь мы начинаем искать объект не по значению хэш-кода («номеру каталога»), а в начале – ищем номер каталога, а потом начинаем перебирать все объекты внутри этого каталога, выбирая тот, который нам нужен.
Внимание! equals() и hashcode() обязательно должны быть согласованы! Метод equals() должен удовлетворять нескольким позициям:
Рефлективность (a.equals(a) должно быть всегда true);
Симметричность (если a.equals(b) == true, то b.equals(a) == true);
Транзитивность (если a.equals(b) == true и a.equals(c) == true, то b.equals(c) == true);
Согласованность (если a.equals(b) == true/false, то это условие сохраняется до смены значения объекта);
Сравнение с null (a.equals(null) == false всегда);
Равенство хэш-кодов (если a.equals(b) == true, то это значит, что хэш-коды у объектов равны. Но обратно это правило не действует!).
Метод hashcode() должен удовлетворять нескольким позициям:
Согласованность (многократный вызов hashcode для одного и того же неизменного объекта всегда возвращает один и тот же результат);
Совместимость с equals (если объекты равны по equals, то у них точно одинаковый хэш-код);
Неравенство по equals (если хэш-коды совпадают, то это не значит, что equals отработает на true для этих объектов);

equals() и hashcode() рекомендовано переопределять, используя аннотацию @Override. В аргументах equals() обязательно (!) должен быть указан Object o. 
При переопределении equals() и hashcode() необходимо указывать одинаковые условия, влияющие на сравнивание объектов. Если мы всё делаем вручную, следует позаботиться о наиболее равномерном распределении кодов (для улучшения быстродействия), а если среди объектов встречаются float или double для переопределения, следует помнить, что они не являются точными и для их грамотной отработки рекомендовано использовать методы Float.floatToIntBits() и Double.doubleToLongBits() соответственно для более точного приведения к целочисленному типу данных
Но лучше всего использовать возможности среды для генерации этих методов.
Материалы любезно предоставлены http://progwards.ru/