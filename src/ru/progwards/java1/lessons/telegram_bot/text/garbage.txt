Garbage Collector. Он же – сборщик мусора.
Для начала вспомним, что такое стек и куча в рамках программы. Любая программа состоит из n потоков, каждый из которых обладает своим стеком; куча – это отдельное хранилище, из которого ресурсы берут все потоки. Локальные переменные и параметры функций (то, что передаётся в функции) хранятся в стеке, при этом примитивы хранятся как значения, а объекты – как ссылки, которые ведут в кучу. Таким образом, в стеке хранятся переменные, в куче хранятся объекты. Сам стек работает по принципу LIFO. Параметры функций (методов) передаются через стек и после завершения функции удаляются. Локальные переменные (примитивы и ссылки) также размещаются в стеке и удаляются после завершения функции.
Проиллюстрируем на примере работы поиска числа Фибоначчи.
Создадим метод, вычисляющий это число через рекурсию.

public class Fibo {
    int prev;
    int curr;

    public Fibo(int prev, int curr) {
        this.prev = prev;
        this.curr = curr;
    }

    Fibo next() {
        return new Fibo(curr, prev + curr);
    }

    @Override
    public String toString() {
        return String.valueOf(curr);
    }
}

Теперь создадим main-метод, который будет отрабатывать с классом Fibo, возвращая результат вычисления числа Фибоначчи.

public class Main {
    public static Fibo getFibo(int num) {
        switch(num) {
            case 1:
                return new Fibo(0, 1);
            case 2:
                return new Fibo(1, 1);
        }
        Fibo preFibo = getFibo(num - 1);
        return preFibo.next();
    }
    public static void main(String[] args) {
        Fibo fibo = getFibo(5);
        System.out.println(fibo);
    }
}
 
Теперь разберём этот код пошагово с точки зрения использования памяти. Каждый раз при вызове функции в стеке формируется блок, в который помещаются переменные (так называемый stackframe). 
Для main он начал формироваться ещё до запуска первого оператора программы. В нём – ссылка на массив String[] args.
Далее мы переходим на стадию формирования объекта fibo из main. Для формирования объекта мы переходим на новый stackframe, и в нём пока что создано значение int=5, которое мы передали внутрь этого stackframe – то есть, мы оказываемся в статическом методе getFibo. Из этого метода мы проходим по оператору switch, и, так как 5 не равно 1 или 2, попадаем в getFibo, который создаёт ещё один stackframe, но уже со значением 4. Так мы и будем создавать новые stackframe, регулярно уменьшаясь на 1, пока не дойдём до значения 2. Тогда процесс пойдёт в обратную сторону.
Теперь мы начинаем «вываливаться по очереди из каждого созданного stackframe, переходя всё выше и выше и уничтожая старые stackframe. В результате мы будем иметь ссылки на объекты args и fibo, а все preFibo потеряют ссылки на себя. То есть теперь мы имеем в куче несколько объектов, к которым не имеем ссылок и, соответственно, не можем ими воспользоваться.
Вот тут на помощь приходит Garbage Collector. Он очищает память от тех объектов, к которым не ведётся ни одна ссылка.
...
Для продолжения наберите "garb2"
Материалы любезно предоставлены http://progwards.ru/