Абстрактный класс – это класс, экземпляр которого невозможно создать, но который создаёт структуру для наследуемых классов. В абстрактном классе присутствуют только сигнатуры методов («оболочка»), реализация будет проходить в классах-наследниках. Если вдруг реализация будет отсутствовать в классе-наследнике, то его также придётся объявить абстрактным.
Абстрактный класс может включать в себя методы с реализацией (они наследуются стандартным способом). Если в классе присутствует хотя бы один абстрактный метод, то класс тоже должен быть абстрактным.
Также можно запретить наследование от какого-либо класса при помощи ключевого слова final. Поэтому класс не может быть одновременно абстрактным и финальным.
Интерфейс – это дополнительное свойство объекта, которое мы прописываем при помощи implements. Это требование к наличию в классе определённых свойств и методов. Интерфейсы позволяют нам работать с несколькими объектами, как с одним. Интерфейс – это, фактически, расширение свойств объектов. Методы в интерфейсах не реализованы.
Если абстрактные классы и наследование – это полиморфизм вертикальный, то интерфейсы – полиморфизм горизонтальный.
Класс, имплементирующий интерфейс, обязан реализовать все методы, заложенные в этом интерфейсе. Но если в интерфейсе мы пометим метод как default, то мы будем обязаны реализовать default-метод прямо в интерфейсе, и не должны будем реализовывать его в имплементирующем классе. 

public interface ITest {
    void action(); // этот метод мы обязаны реализовать в классе
    default void act() { // а этот метод мы можем реализовать в классе, если хотим что-то поменять
        System.out.println("Act in action");
    }
}

Если класс наследует два интерфейса, то в них могут оказать методы с одинаковыми названиями и сигнатурами. Тогда, если это не default-методы – реализация будет в классе; если в одном из классов этот метод default – будет взята default-реализация; если оба метода default, то необходимо будет произвести реализацию в самом классе.
Причём, внутри реализации двух default-методов интерфейсов, внутри можно вызвать default-реализацию определённого интерфейса при помощи синтаксиса: имя_интерфейса.super.имя_метода(аргументы).
Дополнение: в интерфейсах нельзя хранить никакие данные, кроме enum и констант.
public interface ITest {
    enum enumius {ONE, TWO, THREE};
    final static int ZERO = 0;
}

Но, теоретически, Java не будет ругаться, если мы положим туда обыкновенные переменные.
К статической константе и мы не сможем обратиться через экземпляр класса, только через сам класс (соответственно, обращение к константам возможно только через имя интерфейса).
public class Test implements ITest{
    public static void main(String[] args) {
        ITest it = new Test();
        Test test = new Test();
        ITest.enumius i; // к enum/static-полю можно обратиться через имя интерфейса
        int some = Test.ZERO; // к enum/static-полю в интерфейсе можно обратиться также через класс, имплементирующий enum
    }
}

Материалы любезно предоставлены http://progwards.ru/