Функциональный интерфейс - это интерфейс, у которого есть один единственный абстрактный метод (отличный от методов класса Object – методы Object  у нас присутствуют везде). Использовать лямбда-выражения можно только там, где предполагается использование функционального интерфейса.
Рассмотрим пример с TreeSet. Строчка с объявлением внутри конструктора TreeSet  – тоже самое, что и просто объявить TreeSet с компаратором.
TreeSet<Integer> set = new TreeSet<>((o1, o2) -> Integer.compare(Math.abs(o1), Math.abs(o2));

… обращается к конструктору
public TreeSet(Comparator<? super E> comparator) {
    this(new TreeMap<>(comparator));
}

… который возвращает экземпляр с функциональным интерфейсом-компаратором, в который единственным методом вкладывается лямбда-выражение. T (дженерик) определится по ходу работу программы самой программой.
Виды функциональных интерфейсов:
1.Consumer<T> (потребитель) - принимает параметры, метод ничего не возвращает void. Пример использования – однотипные действия с элементами поиска (например, метод foreach() коллекций).
2.Function<T, R> (функция)- принимает параметры и возвращает значение. Пример использования – про объекту T получить объект R (например, свойство T)
3.Predicate<T> (утверждение) - принимает параметры и возвращает значение типа boolean.  Используется, например, для фильтрации данных. 
4.Supplier<> (поставщик) - не принимает параметры, возвращает значение. Пример использования – функция без параметров, например – поставщик результатов (например, случайных чисел).
5.UnaryOperator<T> (унарная операция) - определяет унарную операцию. Наследник Function, но с более простым синтаксисом.
6.BiConsumer<T, U> - принимает два параметра, но ничего не возвращает. В основном используется для работы с map.
7.BiFunction<T, U, R> - принимает два параметра и возвращает значение. Помогает получить объект R по объектам T и U.
8.BinaryOperator<T> - определяет операцию с двумя аргументами (типа T), возвращает аргумент типа T.
Само лямбда-выражение является параметром, который передаётся в функцию, и, поэтому, имеет свой тип – а именно, тип Object, реализующий какой-то функциональный интерфейс.
Примеры функциональных интерфейсов:
Попробуем создать несколько тестовых функциональных интерфейсов. 
Predicate<Integer> isEven = x -> x % 2 == 0; // создание Predicate с переопределённым методом test(), проверяющим входящее число на чётность
System.out.println(isEven.test(1000)); // проверка работы метода
Consumer<Integer> toPrint = x -> System.out.println(x); // создание Consumer c переопределённым методом accept(), выводящим параметр в консоль
toPrint.accept(1000); // проверка работы метода
Consumer toPrintAnything = x -> System.out.println(x); // создаём Consumer без дженерика. Он может напечатать всё.
toPrintAnything.accept("abracadabra"); // в аргумент можно теперь передать всё, что угодно
Function<Double, Double> square = x -> x * x; // создание Function  с переопределённым методом apply(), который принимает один параметр, а возвращает квадрат этого числа
Function <Double, Double> squareRoot = x -> Math.sqrt(x); // создание Function с функцией поиска квадратного корня
Function <Double, Double> mod = x -> squareRoot.apply(square.apply(x)); // создание вложенного Function, когда лямбда-выражение является выполнением внутреннего лямбдя-выражения, который также является выполнением лямбдя-выражения
toPrintAnything.accept(mod.apply(5.0)); // тройная вложенность: Consumer -> Function -> Function -> Function
Supplier<Integer> random = () -> (int) (Math.random() * 10 + 1); // создание Supplier и переопределение метода get(), который теперь возвращает случайный int от 1 до 10 включительно
System.out.println(random.get()); // проверка работы метода
UnaryOperator<Integer> cube = x -> (int) Math.pow(x, 3); // создание UnaryOperator с переопределённым методом apply() (как и у Function, который UnaryOperator наследует), который будет возвращать кубическое значение числа
toPrintAnything.accept(cube.apply(3));
Материалы любезно предоставлены http://progwards.ru/