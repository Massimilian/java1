...
C отложенными методами stream() и filter(λ-выражение), а также формирующими методами collect(Collector.toList()) и count мы уже познакомились.
Отложенные методы min() и max() возвращают минимальное и максимальное значение из потока, которое потом можно достать при помощи формирующего метода get(). Причём в первый раз мы передаём λ-выражение, а во второй раз – статический экземпляр Comparator (в метод которого мы передаём – как получить значение для сравнения – при помощи того же λ-выражения).
System.out.println(list.stream().min((o1, o2) -> Double.compare(o1.price, o2.price)).get()); // выводит книгу с минимальным значением price
System.out.println(list.stream().max(Comparator.comparingDouble(x -> x.price)).get()); // выводит книгу с максимальным значением price

Отложенный метод map(λ-выражение)  преобразует все элементы входящего потока согласно λ-выражению из объектов коллекции в то, что мы пропишем (в приведённом ниже примере – в модифицированные строки). 
list.stream().map(x -> String.format("%s%s%s", "* ", x.author, " *")).forEach(System.out::println); // выведет в консоль всех авторов в синтаксисе "* Автор *"

Отложенный метод flatmap() объединяет несколько коллекций в одну. Для того, чтобы ввести несколько коллекций (или несколько элементов для добавления в коллекцию), используется новый метод Stream.of.
Book book1 = new Book("Сказки", "Братья Гримм", 236);
Book book2 = new Book("Рассказы", "Толстой", 654);
System.out.println(Stream.of(list, asList(book1, book2)).flatMap(x -> x.stream()).collect(Collectors.toList()));

Также при помощи flatmap() можно очистить коллекцию от нулевых значений при помощи внутреннего λ-выражения (flatMap(Stream::ofNullable)).
Различие между flatmap() и map() – flatmap() берёт элементы нескольких коллекций и объединяет их в один поток (который потом можно преобразовать в коллекцию); map() поэлементно преобразует каждый элемент, вытаскивая оттуда значения, добавляя новые и даже меняя тип объекта.
Отложенный метод sorted(λ-выражение) сортирует значения внутри коллекции и упорядочивает их. Если не указать λ-выражение, то сортировка произойдёт по умолчанию. 
list.stream().sorted((o1, o2) -> o1.author.compareTo(o2.author)).collect(Collectors.toList()).forEach(p -> System.out.println(p.author)); //упорядочиваем коллекцию по авторам, сохраняем её в упорядоченном виде и выводим авторов

Формирующий метод reduce(begin, λ-выражение) помогает провести некую единую операцию со всеми элементами поочерёдно – например, сложить в единую строку все названия (вытащенные заранее из списка книг). В качестве begin указывается начальное значение, с которым потом будут работать все элементы коллекции по очереди. Если begin нет, то вернётся объект Optional (обёртка – о нём будет немного позже). 
String authors = list.stream().map(x -> x.name).reduce("", (s, name) -> String.format("%s%s%s%s", s, "'", name, "', ")); // подготавливаем строку из коллекции книг, куда включаем только авторов, далее - превращаем этот поток  в единую строку
System.out.println(String.format("%s%s", authors.substring(0, authors.length() - 2), ".")); // делаем красивое окончание строки и выводим на экран

Ещё один способ использования reduce() – поиск максимального числа (хотя для этого можно использовать метод max()).
System.out.println(List.of(1, 5, 4, 2, 9, 10, -11, 2).stream().reduce(0, (x, a) -> a < x ? x : a)); // выведет максимальное число - 10

Отложенный метод limit(int) обрубает будущий поток, внося туда только int первых значений.
Отложенный метод skip(int) начинает поток именно с элемента, номер которого указан в параметре (int).
Отложенный метод distinct() очищает поток от дубликатов.
Отложенный метод takeWhile(λ-выражение) переносит внутрь потока все выражения, у которых λ-выражение вернёт true; если не вернёт – то метод завершится и больше ничего не добавит.
List.of(2, 3, 4, 5).stream().takeWhile(v -> v % 2 == 0).forEach(System.out::println); // выведет только 2, так как на втором элементе у нас не отработает условие

Отложенный метод dropWhile(λ-выражение) пропускает значения до тех пор, пока λ-выражение не вернёт true; если вернёт – то все остальные значения будут включены в результирующий список.
List.of(2, 3, 4, 5).stream().dropWhile(v -> v % 2 == 0).forEach(System.out::println); // выведет всё, кроме первого значения, которое соответствует заложенному в лямбда-выражении, так как на первом элементе у нас отработает условие

Также Stream обладает собственным итератором. Выглядит он так:
Stream.iterate(0, i -> i <= 10, i -> ++i).forEach(System.out::println);

Поток при помощи метода iterate принимает три параметра – значение, до какого «потолка» меняется значение, как меняется значение – и далее при помощи метода forEach выводим все значения (усечённой лямбдой). Будут выведены числа от 0 до 10.


Материалы любезно предоставлены http://progwards.ru/