...
Явный вызов сборщика мусора – явление редкое, так как сборщики достаточно умны, стобы самостоятельно вызываться когда это надо. В основном сборщик мусора вызывается:
для очистки кэша
для очистки памяти после старта сервера (так как загружаются объекты, которые потом никогда не понадобятся)
для проверки утечек в памяти (при отладке приложения).
Явного управления памятью Java нет. Зато существуют возможности для косвенного управления:
SoftReference – мягкая ссылка – из особых ссылок самая значимая; 
WeakReference – слабая ссылка – из особых ссылок обладающая меньшим весом;
PhantomReference – фантомная ссылка – из особых ссылок – самая лёгкая;
Также существует прямая (сильная) ссылка.
Проведём эксперимент. Создадим класс с ссылками и посмотрим, как они переживут работу GC.

public class Main {
    public static void main(String[] args) {
        SoftReference<String> soft = new SoftReference<>("Мягкая (soft) ссылка");
        WeakReference<String> weak = new WeakReference<>("Слабая (weak) ссылка");
        System.out.println("Значение мягкой ссылки - " + soft.get()); // на данный момент обе ссылки отработают
        System.out.println("Значение слабой ссылки - " + weak.get());
        System.gc();
        System.out.println("После сборки мусора:");
        System.out.println("Значение мягкой ссылки - " + soft.get()); // теперь, после работы GC, есть вероятность, что слабая ссылка теперь будет указывать на null
        System.out.println("Значение слабой ссылки - " + weak.get());
    }
}

Если слабая ссылка будет уничтожена и она будет единственной, кто указывает на объект – то объект становится мишенью для GC.
Основная задача мягкой ссылки – это кэширование. Когда память в куче заканчивается – метод get() мягкой ссылки возвращает null, GC удаляет сам объект, а также все объекты, которые были доступны от этого объекта (если к ним не ведут какие-либо дополнительные не уничтоженные ссылки). Все мягкие ссылки гарантированно будут очищены во время работы GC.
Использовать мягкие ссылки можно в тех местах, где мы используем большое количество данных, которые в скором времени нам не понадобятся (например, при рекурсии).
Есть специальный параметр, который влияет на жизнь мягких ссылок: -XX:SoftRefLRUPolicyMSPerMB=<Y> - время жизни в миллисекундах на каждый свободный мегабайт кучи (после того, как исчезла последняя ссылка на объект – по мнению сборщика мусора). По умолчанию – 1000.
Что касается слабой (weak) ссылки – после первой же чистки мусора эта ссылка в ответ на метод get() будет возвращать null. На Weak-ссылках основан класс WeakHashMap, чей принцип работы – уничтожение и ключа, и значения, если на ключ не осталось сильной ссылки.
Пример использования слабой ссылки – на сайт приходит пользователь и загружает свою карту (например) из хранилища. Что-то с ней делает, уходит. Пользователя нет – стало быть, и карта автоматически уничтожается. Если бы автоматического уничтожения карты не было (как, например, в WeakHashMap<Пользователь, Карта>), то память оказалась бы переполнена различными пользователями.
Итого – слабая ссылка уничтожается при первом же включении GC; мягкая ссылка – кода наступает переполнение памяти.
Чтобы понаблюдать, с какой очерёдностью будут удаляться ссылки, можно завести класс ReferenceQueue и поместить туда те ссылки, про которые мы знаем, что они будут удалены. Используется в исследовательских целях. Именно в связке с ReferenceQueue используется PhantomReference.
Материалы любезно предоставлены http://progwards.ru/