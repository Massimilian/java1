...
Set<Map.Entry<Integer, String>> entries = map.entrySet(); // получение множества (Set) Entry
map.remove(null); // удаление одного элемента незамедлительно скажется на предыдущих трёх коллекциях (Set ключей, коллекция значений и Set Entries) - из них также будут удалены соответствующие значения (null)
System.out.println(collection); // выведет [Number one], только; null был удалён
collection.remove("Number x"); // эксперимента ради удалим из коллекции значение, и это незамедлительно скажется на карте - это значение будет оттуда удалено, причём если таких значений несколько - тогда то, которое ближе к началу
System.out.println(map); // в словаре осталось только одно значение
// collection.add("test"); - а вот этого делать нельзя, будет выброшено UnsupportedOperationException
// таким образом можно вывести правило - полученные из HashMap (и HashTable) коллекции - это просто оболочки над данными, и изменения в данных и в оболочках взаимосвязаны

Добавление и работа итератора (по ключу и по значению) в HashMap немного быстрее, чем в HashTable; поиск в HashMap в два раза медленнее, чем в HashTable. В HashMap и HashTable методы containsValue() – медленное, containsKey() – быстрое.

LinkedHashMap - словарь, хранящий порядок добавления элементов. Наследуется от HashMap. Основан на хэш-таблице. Для эффективной работы нужна хорошая функция хэш-кода для ключа. В остальном – работает на тех же методах, что и HashMap и HashTable.
Строение HashMap - Для того, чтобы понять, как строится HashMap, нужно заглянуть в строение Entry. Это – интерфейс с реализацией в виде класса Node, который имеет следующие поля:
final int hash;
final K key;
V value;
Node<K,V> next;

… где hash – это hash-адрес в памяти; key – ключ; value – значение; next – следующее значение в корзине. 
	При создании нового HashTable создаётся массив table из 16 Node, которые пока все равны null. В этом массиве будут храниться Node, в каждом из которого будут храниться ключ-значение и hash-код ключа. При положении туда значения (функция put()), происходят следующие действия:
•	Вычисляется hash-код ключа;
•	Рассчитывается позиция в массиве, на которую влияет hash ключа;
•	Создаётся Node и в массиве размещается ссылка на Node; ссылка на следующий элемент пока что равна null.
При дальнейшем положении внутрь массива table возможны две ситуации: ячейка свободна – тогда мы кладём значение по вышеизложенному алгоритму; ячейка занята – тогда мы заполняем hash-код ключа, собственно ключ и значение, а в качестве next – указываем ссылку на тот Node, который уже находился на позиции в массиве table. Теперь в этом месте будет лежать новое значение, в котором будет находиться ссылка на старое значение. В результате мы получаем однонаправленный связанный список. Содержимое каждой ячейки table принято называть корзиной. 
В какой-то момент насыщение массива становится слишком большим (количество Node – loadFactor – становится равным 75% от размера table). Тогда массив автоматически увеличивается на 100%. В новом массиве все Node перераспределятся заново. Именно поэтому порядок элементов в hash-таблице не определён, и, более того, может ещё и поменяться. 
Если искусственно переписать функцию расчёта hash и сделать так, чтобы значение возвращалось всё время одинаковое – то быстродействующая hash-таблица превратится в медленный список. На hash-код влияет ключ, следовательно, необходимо позаботиться, чтобы функция расчёта hash была написана хорошо. 
При поиске в hash-таблице рассчитывается hash-код ключа, выбирается нужная корзина и методом перебора вынимается нужный элемент. В идеале ничего перебирать не надо, и мы сразу забираем элемент. 
...
Для продолжения наберите "ma3"

Материалы любезно предоставлены http://progwards.ru/