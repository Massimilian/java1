
Deque (double ended queue) - это наследный интерфейс от Queue, так называемая двусторонняя очередь. То есть элемент можно положить/взять и в начале, и в конце очереди.  Этот интерфейс реализуется классами LinkedList и ArrayDeque. Как и в интерфейсе Queue, методы есть пробрасывающие исключения и не пробрасывающие. 
Также в двусторонней очереди реализованы методы стэка: push() – положить что-то в очередь и pop() – взять что-то из очереди (сверху). Не забываем, что здесь действует принцип LIFO. Эти методы могут выбросить исключение. Элементы кладутся и берутся из начала.
Пример работы с двусторонней очередью как стэком:
ArrayDeque<Integer> ad = new ArrayDeque<>();
ad.push(1);
ad.push(2);
ad.push(3);
while(!ad.isEmpty()) {
    System.out.println(ad.pop()); // элементы будут вытащены с 3 до 1
}

ArrayDeque – реализация интерфейса Queue (классической очереди). Построен ArrayDeque на основе массива.
Когда мы только создаём ArrayDeque, он выглядит как массив с capacity == 16, полностью заполненный null, и два указателя («начало» и «конец») – изначально оба показывает на нулевой элемент null. 
Когда мы добавляем в начало объект, то в куче создаётся объект, а в ArrayDeque помещается ссылка на этот объект. Указатель «конец» съезжает на одну позицию выше. При полном заполнении ArrayDeque увеличится не на 50% (как ArrayList), а на 100%. 
Если мы забираем элемент из начала, соответствующая ссылка в массиве становится равной null, а указатель «начало» смещается на одну позицию выше.
Если мы забираем элемент из конца, соответствующая ссылка в массиве становится равной null, а указатель «конец» смещается на одну позицию ниже.
Если мы добавляем элемент в начало, то на самом деле он добавляется в самый конец, а указатель «начало» теперь будет указывать на самый последний элемент. Таким образом, мы как бы «закольцовываем» массив, связывая нулевой и последний элементы, ставя их один за другим. .

ArrayDeque<Integer> ad = new ArrayDeque<>();
ad.add(null); // выбросит NullPointerException
ad.offer(null); // тоже выбросит NullPointerException.
 
Вывод – в ArrayDeque нельзя добавлять null в качестве значения.
ArrayDeque<Integer> ad = new ArrayDeque<>();
ad.element(); // выбросит NoSuchElementException
ad.remove(); // тоже выбросит NoSuchElementException
	
Вывод – взять элемент оттуда, где его нет, при помощи методов element() и remove(), приведёт к NoSuchElementException.

ArrayDeque<Integer> ad = new ArrayDeque<>();
System.out.println(ad.peek()); // вернёт null
System.out.println(ad.poll()); // вернёт null

Вывод – peek() и poll() возвращают значение либо null. Этими методами можно проверять, является ли очередь пустой.
При сравнении скорости работы ArrayDeque и LinkedList очередь работает в 3 раза быстрее при добавлении элемента; в 5 раз быстрее, если известно изначальное количество добавляемых элементов (capacity) и оно прописано в ArrayDeque (в LinkedList capacity добавить невозможно); в два раза быстрее при последовательном заборе элементов.
Итого: для работы с очередью лучший выбор – ArrayDeque.

Материалы любезно предоставлены http://progwards.ru/