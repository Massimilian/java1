...
HashSet – множество на Hash-таблице. Hash-таблица состоит из двух элементов – собственно объект и его числовое отображение. Hash-таблица состоит из всегда уникальных значений; порядок элементов HashSet не определён; добавление элементов происходит медленнее, чем в список, но незначительно; поиск и удаление элементов значительно быстрее, чем в списке (это – главное преимущество множества перед списком); отсутствует возможность редактировать объект в таблице (наподобие List.set).
	Множество также может иметь итератор. При невозможности обратиться к какому-либо конкретному индексу, мы можем пробежаться по всем значениям при помощи итератора.
	Конструкторы HashSet:
•	HashSet() – создаёт пустое множество;
•	HashSet(Collection<? extends E> coll) – создаёт множество на основе коллекции coll;
•	HashSet(int initialCapacity) – создаёт множество с указанным параметром initialCapacity;
•	HashSet(int initialCapacity, float loadFactor) - создаёт множество с указанными параметрами initialCapacity и loadFactor.

	Проверка на добавление новых элементов:
HashSet<AtomicInteger> set = new HashSet<>();
set.add(new AtomicInteger(1));
set.add(new AtomicInteger(1));
System.out.println("Количество элементов - " + set.size()); // выведет 2, так как это будет два объекта с разными hash-кодами
for (AtomicInteger ai : set) {
    System.out.println(ai.get() + "; " + ai.hashCode()); // выведет два объекта с одним значением, но разным hash-кодом
}

Как видно из эксперимента, что оригинальность объекта проверяется по его hash-коду. Если hash-код не совпал – объекты разные (даже по сути одинаковые). Соответственно, объект должен переопределять equals() и hashcode() для грамотной отработки.
Для определения принадлежности объекта какого-нибудь классу используется либо getClass() (возвращает объект типа Class<?>, к которому принадлежит объект), либо instanceOf (возвращает true для объекта того же класса либо родительского). Сравнивать лучше через getClass().
Вообще для множеств следует использовать Inmutable (неизменяемые), а если пришлось использовать изменяемые – следует внимательно следить за логикой программы (потому что множество может перестать быть множеством.


LinkedHashSet - наследник HashSet. Главное отличие – в LinkedHashSet данные упорядочены по времени добавления. Повторяющиеся значения также не будут добавлены. Конструкторы – в точности такие же, как в HashSet. 
TreeSet - реализация интерфейса SortedSet. Элементы здесь сортируются автоматически, поэтому им нужен компаратор (либо класс, реализующий интерфейс Comparable).
	Конструкторов всего 4:
•	TreeSet() – конструктор по умолчанию;
•	TreeSet(Collection<? extends E> c) – конструктор со входным значением коллекции;
•	TreeSet(Comparator<? Super E> comparator) – конструктор с заданным компаратором, а если элементы Comparable – нововведённый компаратор становится главным;
•	TreeSet(SortedSet<E> s) – конструктор со входным параметром типа SortedSet и таким же компаратором, как и в s.
Внимание! Если элементы не реализуют Comparable или Comparator не задан – TreeSet не удастся создать.
Пример конструктора с компаратором, который сравнивает числа по модулю:
TreeSet<Integer> treeSet = new TreeSet<>(new Comparator<Integer>() {
    @Override
    public int compare(Integer o1, Integer o2) {
        return Integer.compare(Math.abs(o1), Math.abs(o2));
    }
});

Внимание! Сравнение объектов внутри TreeSet происходит на основе компаратора, а не equals()! 

...
Для продолжения наберите "se3"

Материалы любезно предоставлены http://progwards.ru/