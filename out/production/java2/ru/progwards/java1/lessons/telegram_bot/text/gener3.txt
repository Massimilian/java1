...
У Generic есть ограничения:
Они не принимают примитивы, только ссылочные типы; проблем с обратным преобразованием в примитивы не будет – будет происходить boxing и unboxing;
В runtime можно запрашивать только базовый тип или его ограничение. То есть мы можем, например, проверить, является ли “a” типом “Example” (a instanceof Example), но не можем проверить типизацию (a instanceof Example<Pair> - приведёт к ошибке на этапе компиляции) – иными словами, типизация не проверяется в режиме runtime;
Массивы параметризированных типов, созданные внутри метода, недопустимы. SomeClass<Integer>[] someclass = new SomeClass<Integer>[1]; // ошибка. Теоретически можно обхитрить Java, создав новый массив объектов: SomeClass<Integer>[] someclass = new SomeClass[1]; , ошибки не будет; но потом могут быть неудобства при работе с таким массивом. Лучше использовать более высокоуровневые средства хранения данных. 
Нельзя создавать новые экземпляры типа обобщений. T t = new T() – приводит к ошибке. Обходной путь – создать объект и привести его к нужному типу – T t = (T) new Object();. Также невозможно получить в runtime T.class.
Переменные типа в статическом контексте недействительны. Если мы собираемся работать с обобщением внутри статического класса, то необходимо указать его после слова static во главе класса. Создать статическую переменную обобщённого типа нельзя. Причина – статический контекст появляется раньше инициализации, а переменные мы инициализируем позже. SomeClass<Integer>[] someclass = new SomeClass<Integer>[1];
Нельзя генерировать или перехватывать экземпляры обобщённого класса в виде исключений. Нельзя создать типизированное исключение.
	Generic вводится в название класса в том случае, когда внутри мы будем использовать поля с использованием обобщённого типа (и в таком классе могут быть не типизированные методы).
public class Generic <T>{
    T t;
    
    public void example() {
        System.out.println();
    }
}

Наоборот тоже действует – внутри класса без обобщений может быть метод с Generic.
public class Generic{

    public<T> T example(T t) {
        return t;
    }
}

	Задача: написать метод, который сравнивает два однотипных объекта любого типа.
Решение: через Generic сравниваем два объекта и возвращаем результат.

public class Generic{
    public <T> T compare(T t1, T t2) {
        T temp = null;
        if (t1.compareTo(t2) == 1) {
            temp = t2;
        } else {
            temp = t1;
        }
        return temp;
    }
}

Но этот код не отработает, так как мы не знаем, каким образом сравниваются классы типа T. Для их нормального сравнения необходимо, чтобы на нашем Generic также лежало ограничение и класс T наследовался от Comparable. Это немного меняет код:
public class Generic{
    public <T extends Comparable> T compare(T t1, T t2) {
        T temp = null;
        if (t1.compareTo(t2) == 1) {
            temp = t2;
        } else {
            temp = t1;
        }
        return temp;
    }
}

...
Для продолжения наберите "gene4"
Материалы любезно предоставлены http://progwards.ru/