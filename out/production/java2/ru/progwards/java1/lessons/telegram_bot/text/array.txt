Массив – это набор значений определённого типа. Размер задаётся при создании и размер далее не меняется. У массивов очень эффективный доступ к элементу – практически мгновенно можно вытащить значение по индексу. В памяти массив размещается единым блоком, а выделяемая память зависит от заявляемого размера массива.
	В памяти массив хранится как объект. Размер массива зависит от типа данных, которые лежат в нём, и количества этих данных. Если мы создаём массив объектов, то в массиве хранятся не сами объекты, а ссылки на них.
	С массивами возможны различные операции:
int[] a = {3, 2, 1};
int[] b = {3, 2, 1};
System.out.println(Arrays.toString(a)); // представление массива в виде строки и вывод его на консоль в читаемом формате
System.out.println(Arrays.equals(a, b)); // проверка на равенство; вернёт true, так как массивы равны
Arrays.fill(a, 10); // заполнение массива a значениями 10; если массив не заполнен при инициализации, то до этого метода все значения будут инициализированы по умолчанию
int[] с = Arrays.copyOf(a, a.length); // копирование массива, где первый аргумент - это сам массив, второй - это количество аргументов для копирования. Создаёт именно самостоятельную копию, а не дополнительную ссылку.
int[] x = new int[a.length];
System.arraycopy(a, 0, x, 0, a.length); // ещё один способ копирования элементоы, где в качестве аргументов принимаются название массива-отправителя, номер элемента, с которого копируем, название массива-получателя, номер элемента, с которого вставляем, количество вставляемых элементов. Метод более громоздкий, но более быстрый
Arrays.sort(b); // сортировка массива; теперь вместо {3, 2, 1} будет {1, 2, 3}
Arrays.binarySearch(b, 1); // быстрый поиск значения 1 в отсортированном массиве (методом деления на 2) и возврат номера ячейки с хранимым значением; если значение не найдено, вернёт отрицательное число

	ВНИМАНИЕ! Если мы работаем с массивами объектов (например, массивом массивов), то при сравнении будут сравниваться объекты, которые, даже если и одинаковые, но инициализированы в разных местах, будут рассматриваться как разные объекты (если только у них не переопределён метод equals()). Также будет не совсем грамотно работать отображение на консоли при помощи метода toString().
int[] a = {3, 2, 1};
int[] b = {3, 2, 1};
int[][] aa = {a, b, a};
int[][] bb = {a, a, a};
System.out.println(Arrays.equals(aa, bb)); // выведет false, так как объекты не одни и те же (хоть и де-факто равные)
System.out.println(Arrays.toString(aa)); // выведет читаемый список объектов в нечитаемом формате

	Для того, чтобы всё отработало грамотно, необходимо использовать немного другие, так называемые deep-методы.
int[] a = {3, 2, 1};
int[] b = {3, 2, 1};
int[][] aa = {a, b, a};
int[][] bb = {a, a, a};
System.out.println(Arrays.deepToString(aa)); // теперь всё будет введено на консоль с захождениемм в содержимое объекта
System.out.println(Arrays.deepEquals(aa, bb)); // вернёт true, так как сравниваться будут не сами объекты, а их содержимое

	Не стоит забывать, что массив объектов выглядит как массив ссылок на объекты. Поэтому, если мы копируем массив объектов, мы просто копируем ссылки на объекты, и любое изменение ссылок приведёт к изменениям в первоначальных объектах. При этом стоит аккуратно работать с классами-обёртками и String, которые не позволяют менять значения, на которых они инициализированы – создаётся каждый раз новый объект.
String[] a = {"One", "Two", "Three"};
String[] b = Arrays.copyOf(a, a.length); // в массив b скопированы ссылки
b[0] = "One-one";
System.out.println(Arrays.toString(a)); // выведет НЕИЗМЕНЁННЫЙ массив a (все ссылки остались прежние)
System.out.println(Arrays.toString(b)); // выведет ИЗМЕНЁННЫЙ массив b (ссылка на элемент "0" поменялась). Тоже самое будет с обёртками.

Материалы любезно предоставлены http://progwards.ru/