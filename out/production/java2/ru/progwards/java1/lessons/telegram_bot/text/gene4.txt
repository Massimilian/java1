...
Причём Comparable – это интерфейс, то есть мы можем наследовать несколько интерфейсов и один класс (перечислив всё через значок & - например, <T extends People & Comparable & Serializable>, причём при перечислении мы сначала указываем класс, а потом - интерфейсы).
Теперь, когда мы отправляем в этот метод два экземпляра класса, то Java проверяет на то, что этот класс имплементирует Comparable. Если нет – на стадии компиляции код не отработает. Нам придётся имплементироваться от Comparable и, как следствие, реализовать метод compareTo.
Все проверки происходят на стадии компиляции; JVM Generic пропускает, так как не видит; другими словами, в RunTime все типизации стираются. Классы, где вместо Generic употребляется Object, называется «сырой тип». Если же Generic имеет ограничения (например, <T extends Comparable>), то при компиляции JVM превратит его не в Object (как будет с обобщениями без ограничений), а в ограничение (в данном случае – Comparable).
Особенность наследования – если создать Класс<Экземпляр> и Класс<Наследованный экземпляр>, причём классы Экземпляр и Наследованный экземпляр связаны между собой, как родительский класс и наследник, то при компиляции оба класса будут лишены этих связей и оба превратятся в Object.
Задача – написать метод, который сможет распечатать любую коллекцию.
Первый вариант:
public void print(List<String> list) {
    System.out.println(list);
}

Вариант не очень хорош, так как он помогает распечатать только лист из String.
Второй вариант – изначально создать такой класс, который работает с определённым типом переменных.

public class Generic <T>{
    public void print(List<T> list) {
        System.out.println(list);
    }
}

Этот вариант лучше, но теперь мы должны создать экземпляр класса, который будет работать именно с нашим типом переменных.
Наконец – третий вариант – передать в качестве экземпляра знак вопроса, сигнализировав, что этот метод может работать вообще с любым классом, вызывая у него метод toString().
public class Generic {
    public void print(List<?> list) {
        System.out.println(list);
    }
}

Теперь мы можем убрать ограничение из названия класса. Знак вопроса – это тот же сырой тип (то есть мы выражаем готовность работать с Object или его наследниками), то есть в принципе запись может быть даже такой:
public class Generic {
    public void print(List list) {
        System.out.println(list);
    }
}

Но – представим, что нам нужно наложить некоторое ограничение – например, только те классы, которые реализуют Comparable. Тогда синтаксис такой:
public class Generic {
    public void print(List<? extends Comparable> list) {
        System.out.println(list);
    }
}
...
Для продолжения наберите "gen5"
Материалы любезно предоставлены http://progwards.ru/