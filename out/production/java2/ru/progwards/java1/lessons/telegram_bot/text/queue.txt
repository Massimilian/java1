Очереди могут быть двух типов – Lirst In Fast Out (LIFO – так называемый стэк) и First In First Out (FIFO – классическая очередь). 
Queue - это интерфейс всех очередей. Имеет две группы методов – бросающие и не бросающие исключения (по функционалу обе группы дублируют друг друга).
•	boolean add(E e) – добавляет элемент в конец очереди, при неудаче бросает исключение;
•	E element() – смотреть элемент в начале очереди, не убирая его оттуда; при неудаче бросает исключение;
•	E remove() – взять элемент из начала очереди; при неудаче бросает исключение;
•	boolean offer(E e) – добавить элемент в конец очереди, исключение может бросить;
•	E peek() – смотреть элемент в начале очереди, не убирая его оттуда; исключение не бросает, если элемента нет – возвращает null;
•	E poll() – взять элемент из начала очереди; исключение не бросает, если элемента нет – возвращает null.
PriorityQueue – очередь с приоритетом. Имплементирует интерфейс Queue и наследует класс AbstractQueue. Принцип работы очереди с приоритетом – каждый вставляемый в очередь элемент обладает уровнем приоритета. Все элементы в очереди формируют порядок с учётом приоритета: чем выше приоритет, тем ближе к выходу из очереди. При этом при вставлении нового элемента если оказывается элемент с таким же приоритетом, элемент может быть вставлен как до элемента с равным приоритетом, так и после (иными словами, при совпадении приоритетов два элемента теряют строгую последовательность между собой). Соответственно, объекты должны сравниваться друг с другом – либо с помощью реализации интерфейса Comparable, либо через компаратор.
	Иными словами, очередь с приоритетом являются сортирующей очередью.

PriorityQueue<Integer> pq = new PriorityQueue<>();
pq.offer(1); // добавляем числа в рандомном порядке
pq.offer(2);
pq.offer(7);
pq.offer(4);
pq.offer(3);
pq.offer(5);
pq.offer(6);
while(pq.peek() != null) {
    System.out.println(pq.poll()); // выведет упорядоченные числа от 1 до 7
}

	Теперь создадим очередь с приоритетом с обратной сортировкой. Для этого нужно передать в конструктор соответствующий компаратор.

Comparator<Integer> comparator = new Comparator<Integer>() { // создаём компаратор через анонимный класс
    @Override
    public int compare(Integer o1, Integer o2) {
        return o2.compareTo(o1);
    }
};
PriorityQueue<Integer> pq = new PriorityQueue<>(comparator);
pq.offer(1); // добавляем числа в рандомном порядке
pq.offer(2);
pq.offer(7);
pq.offer(4);
pq.offer(3);
pq.offer(5);
pq.offer(6);
while(pq.peek() != null) {
    System.out.println(pq.poll()); // выведет упорядоченные числа от 7 до 1
}

В очередь с приоритетом нельзя добавлять null.	
Обычно в PriorityQueue добавляются экземпляры класса, в котором есть параметр типа Integer, указывающий на приоритет, а также компаратор, который помогает сравнивать приоритеты объектов.
Внимание! Итератор не гарантирует правильную последовательность при выводе элементов.
Добавление элементов осуществляется очень быстро (быстрее TreeSet и чем добавление и сортировка ArrayList); чтение медленное; поиск элементов сверхмедленный. Вывод – PriorityQueue удобен, но неспешен.
...
Для продолжения наберите "queu2"

Материалы любезно предоставлены http://progwards.ru/