Возьмём пример с книгами. Дано – есть коллекция с элементами Book. Задача – необходимо отсортировать их.
Book:
public class Book {
    String name;
    String author;
    double price;

    public Book(String name, String author, double price) {
        this.name = name;
        this.author = author;
        this.price = price;
    }

    public String toString() {
        return String.format("%s, author - %s, price: %f", this.name, this.author, this.price);
    }
}

Теперь создадим фильтрацию по условию price < 500 в классическом стиле и стиле Stream API:
public class TestArea {
    public static void main(String[] args) {
List<Book> list = new ArrayList<>(List.of(
        new Book("Капитанская дочь", "Пушкин", 243),
        new Book("Мастер и Маргарита", "Булгаков", 534),
        new Book("Евангелие от Петра", "Апостол Пётр", 435),
        new Book("Кулинарные рецепты", "Повар", 132)
));
// классическая фильтрация
        List<Book> filtered = new ArrayList<>();
        for (Book elem : list) {
            if (elem.price < 500) {
                filtered.add(elem);
            }
        }
        System.out.println(filtered);

// фильтрацию через Stream API
        List streamFiltered = list.stream().filter(x -> x.price < 500).collect(Collectors.toList());
        System.out.println(streamFiltered);
    }
}

Обе фильтрации возвращают одинаковый результат. Но вторая оказывается значительно короче и нагляднее. Что в ней происходит:
1.При помощи stream() мы превращаем list в поток.
2.При помощи filter(λ-выражение) мы оставляем только те значения в потоке, которые соответствуют проверке через вложенное λ-выражение.
3.При помощи collect(Collectors.toList()) мы возвращаем поток в состояние коллекции.
В данном случае, так как мы имеем дело с функциональным программированием, у нас вводятся новые понятия:
1.Отложенная операция – это операция, которая задаёт условия, но ничего не создаёт. В данном контексте это – stream() и filter(). Иногда называется промежуточной, конвейерной или ленивой.
2.Терминальная операция – это операция, которая создаёт по тем условиям, которые ей продиктованы. В данном случае это – collect(). Иногда называется эффективной или энергичной. До вызова метода collect() собственно фильтрация не происходит – пока только создаются правила.
Ещё один пример фильтрации – только на этот раз по имени (первая буква – «К») – отложенные операции stream() и filter() – и выводим количество – терминальная операция count().
System.out.println(list.stream().filter(x -> x.name.matches("[К].[\\D]*")).count()); // вернёт 2

Итого:
1.Потоки (stream-операции) на основе коллекций подобны итераторам в том смысле, что предоставляют механизм поочерёдного доступа ко всем элементам.
2.Они состоят из отложенных (собственно готовящих условие) и формирующих (собственно готовящих результат) методов. Реальное прохождение по элементам происходит при вызове формирующего метода.
3.Формирующий метод – только один. Отложенных может быть несколько. Если бы формирующие операции встречались не только в самом конце, нам бы приходилось много раз пробегаться по списку, что было бы излишне расточительно с точки зрения ресурсов.

...
Для продолжения наберите "strea2"
Материалы любезно предоставлены http://progwards.ru/