Числа для компьютера выглядят как набор бит определённой длины – byte (8 бит), short (16 бит), int (32 бита), long (64 бита). Битовыми операциями называются операции над битами числа или чисел. Битовая операция проводится над всеми битами по очереди. 
Виды битовых операций:
1.С двумя значениями:
& - побитовое «и» (AND). Результат равен 1, только если оба оператора равны 1.
| - побитовое «или» (OR). Результат равен 1, если хотя бы один из операторов равен 1.
^ - побитовое исключающее «или» (XOR). Результат равен 1, только если операторы противоречат друг другу.
2.	С одним значением:
>> - сдвиг вправо. Сдвигает всё число направо побитово. Соответствует в десятичной системе делению на 2.
>>> - сдвиг вправо с заполнением нолями. Работает почти так же, как и предыдущая операция, но при этом заполняет освободившиеся биты (самые левые) не 1 или нолём в зависимости от того, какой бит был до этого, а всегда нолём.
<< - сдвиг влево. Сдвигает побитово всё число налево (справа ставится ноль). Соответствует умножению на 2 (столько раз, сколько будет сдвигов).
~ - побитовое унарное отрицание (NOT). Меняет результат числа на противоположный.

Для записи чисел недвоичной системы используются так называемые литералы. В Java можно дополнительно отображать числа в следующих системах при помощи литералов:
1.Двоичной (литерал – 0b). Например, 0b10 = 2;
2.Восьмеричной (литерал - 0). Например, 0765 = 510;
3.Шестнадцатеричной (литерал – 0x). Например, 0x1FA = 506;
Теперь поэкспериментируем с битовыми операциями:
int x = 0b1100; // битовое 12
int y = 0b1010; // битовое 10
System.out.println(x&y); // выведет 1000, которое в десятичном представлении = 8.
System.out.println(x|y); // выведет 1110, которое в десятичном представлении = 14.
System.out.println(x^y); // выведет 0110, которое в десятичном представлении = 6.
int x = 2; // заводим число 2 ( (0)10 в десятичном представлении)
int y = x >> 1; // сдвигаем биты вправо (получаем (0)1). В данном случае 1 - это количество сдвигов.
System.out.println(y); // результат: 1.
y = y >> 1; // сдвигаем биты вправо, получаем (0). Последняя единица теряется.
System.out.println(y); // результат: 0.
x = -2; // (1)10 в десятичном представлении. Если число отрицательное, то знаковый бит сохраняется при сдвиге.
y = x >> 1; // сдвигаем биты вправо (получаем (1) ).
System.out.println(y); // результат: -1.
y = y >> 1; // но теперь дальнейшие сдвиги будут приводить к сохранению того же значения (1).
System.out.println(y); // результат: -1.
x = -1025; // (1)0000000001 в десятичном представлении.
y = x >>> 1; // сдвиг с заполнением нолями. Результат: 0(1)000000000
System.out.println(y); // будет выведено 2147483135
x = 1;
y = x << 10; // сдвигаем 10 раз налево - фактически 10 раз умножаем на 2
System.out.println(y); // результат: 1024
x = 0; // делаем значение равным (0)
y = ~x; // меняем все биты на противоположные, получаем (1)
System.out.println(y); // вывод: -1
...
Для продолжения наберите "bit2"
Материалы любезно предоставлены http://progwards.ru/