...
Отложенный метод limit(int) обрубает будущий поток, внося туда только int первых значений.
Отложенный метод skip(int) начинает поток именно с элемента, номер которого указан в параметре (int).
Отложенный метод distinct() очищает поток от дубликатов.
Отложенный метод takeWhile(λ-выражение) переносит внутрь потока все выражения, у которых λ-выражение вернёт true; если не вернёт – то метод завершится и больше ничего не добавит.
List.of(2, 3, 4, 5).stream().takeWhile(v -> v % 2 == 0).forEach(System.out::println); // выведет только 2, так как на втором элементе у нас не отработает условие

Отложенный метод dropWhile(λ-выражение) пропускает значения до тех пор, пока λ-выражение не вернёт true; если вернёт – то все остальные значения будут включены в результирующий список.
List.of(2, 3, 4, 5).stream().dropWhile(v -> v % 2 == 0).forEach(System.out::println); // выведет всё, кроме первого значения, которое соответствует заложенному в лямбда-выражении, так как на первом элементе у нас отработает условие

Также Stream обладает собственным итератором. Выглядит он так:
Stream.iterate(0, i -> i <= 10, i -> ++i).forEach(System.out::println);

Поток при помощи метода iterate принимает три параметра – значение, до какого «потолка» меняется значение, как меняется значение – и далее при помощи метода forEach выводим все значения (усечённой лямбдой). Будут выведены числа от 0 до 10.

Формирующий метод reduce(begin, λ-выражение) помогает провести некую единую операцию со всеми элементами поочерёдно – например, сложить в единую строку все названия (вытащенные заранее из списка книг). В качестве begin указывается начальное значение, с которым потом будут работать все элементы коллекции по очереди. Если begin нет, то вернётся объект Optional (обёртка – о нём будет немного позже). 
String authors = list.stream().map(x -> x.name).reduce("", (s, name) -> String.format("%s%s%s%s", s, "'", name, "', ")); // подготавливаем строку из коллекции книг, куда включаем только авторов, далее - превращаем этот поток  в единую строку
System.out.println(String.format("%s%s", authors.substring(0, authors.length() - 2), ".")); // делаем красивое окончание строки и выводим на экран

Ещё один способ использования reduce() – поиск максимального числа (хотя для этого можно использовать метод max()).
System.out.println(List.of(1, 5, 4, 2, 9, 10, -11, 2).stream().reduce(0, (x, a) -> a < x ? x : a)); // выведет максимальное число - 10

Отложенный метод limit(int) обрубает будущий поток, внося туда только int первых значений.
Отложенный метод skip(int) начинает поток именно с элемента, номер которого указан в параметре (int).
Отложенный метод distinct() очищает поток от дубликатов.
Отложенный метод takeWhile(λ-выражение) переносит внутрь потока все выражения, у которых λ-выражение вернёт true; если не вернёт – то метод завершится и больше ничего не добавит.
List.of(2, 3, 4, 5).stream().takeWhile(v -> v % 2 == 0).forEach(System.out::println); // выведет только 2, так как на втором элементе у нас не отработает условие

Отложенный метод dropWhile(λ-выражение) пропускает значения до тех пор, пока λ-выражение не вернёт true; если вернёт – то все остальные значения будут включены в результирующий список.
List.of(2, 3, 4, 5).stream().dropWhile(v -> v % 2 == 0).forEach(System.out::println); // выведет всё, кроме первого значения, которое соответствует заложенному в лямбда-выражении, так как на первом элементе у нас отработает условие

Также Stream обладает собственным итератором. Выглядит он так:
Stream.iterate(0, i -> i <= 10, i -> ++i).forEach(System.out::println);

Поток при помощи метода iterate принимает три параметра – значение, до какого «потолка» меняется значение, как меняется значение – и далее при помощи метода forEach выводим все значения (усечённой лямбдой). Будут выведены числа от 0 до 10.

Материалы любезно предоставлены http://progwards.ru/