Присваивание типов самым простым способом осуществляется при помощи оператора равно. Тогда необходимо присваивать меньшие по объёму памяти типы в старшие (byte -> short -> int -> long; float -> double). 

byte b = 127;
short sh = b;
int i = sh;
long l = i;
float fl = l; // да, и такое тоже возможно из-за особенностей строения вещественных чисел. Внимание! Возможна потеря точности!
System.out.println(fl); // выведет 127.0
float f = 3.04f;
double d = f;
System.out.println(d); // выведет почти 3.04 (особенности преобразования)

Однако в обратную сторону это не работает. Поэтому обратно следует использовать явное приведение типов.
long l = 25L;
int i = (int) l;
short sh = (short) i;
byte b = (byte) sh;
System.out.println(b);

При явном приведении целочисленных типов используется «отбрасывание» байтов (которые не попадают внутрь диапазона), поэтому, если они ненулевые, то значение числа поменяется. Нулевыми они могут быть только в том случае, если число укладывается в рамки того типа, куда мы присваиваем число. Поэтому следует быть аккуратным при использовании явного присваивания чисел.
При явном приведении вещественных чисел происходит потеря точности.

double d = 3.3355779922;
float f = (float) d;
System.out.println(f); // будет выведено 3.335578

Если мы возьмём очень большое число, которое не помещается в float и попытаемся поместить его во float, произойдёт следующее:

double d = 1e308;
float f = (float) d;
System.out.println(f); // будет выведено Infinity

Infinity (бесконечность) – это специальный идентификатор, который подразумевает несколько особенностей. Любые операции по арифметическим изменениям этой сущности будут давать Infinity; деление на Infinity будет давать в результате 0. Проверить, является данное значение float = Infinity можно при помощи метода Float.isInfinity(значение).
Приведение вещественных чисел к целочисленным приводит к отбрасыванию дробной части. Причём и в случае с double, и с float.

double d = 125.55555555;
System.out.println((byte) d); // выведет 125
System.out.println((short) d); // выведет 125
System.out.println((int) d); // выведет 125
System.out.println((long) d); // выведет 125

Если же число изначально выбивается за пределы допустимых значений, то происходит следующее:

double d = 999999999999999999999999.55555;
System.out.println(d); // выведет 1.0E24, то есть значение, округлённое до 1 с большим количеством нолей 
System.out.println((byte) d); // выведет -1, что является особенностью Java
System.out.println((short) d); // выведет -1, что также является особенностью Java
System.out.println((int) d); // выведет 2147483647, то есть максимально возможное значение int
System.out.println((long) d); // выведет 9223372036854775807, то есть максимально возможное значение long

Вывод – необходимо внимательно следить за диапазоном при приведении типов.

Дополнительные способы проверки объектов для приведения:
instanceOf – возвращает true, если второй объект относится к тому же классу либо наследует этот класс.
getClass() – возвращает класс. На этот раз «фокус» с потомками не пройдёт – при сравнении двух объектов o1 и o2 они должны быть строго одного класса – только тогда вернёт true следующее выражение – o1.getClass() == o2.getClass(). Вызвать имя класса из самого названия класса можно при помощи синтаксиса Класс.class.
isInstance() – работает на подобие instanceOf. Например – с объектами o1 и o2 -  o1.getClass().isInstance(o2.getClass()).
Кастование объекта осуществляется двумя способами – при помощи указания объекта в скобках (Object o1 = (Object) o2;) и при помощи метода cast() ( Object o1 = Object.class.cast(o2);). 

Материалы любезно предоставлены http://progwards.ru/